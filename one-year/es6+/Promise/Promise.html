<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Promise</title>
</head>
<body>
  <script>
    /**
     * Promise是ES6引入的异步编程解决方式。
     * 语法上Promise是一个构造函数，用来封装异步操作并可以补货成功或者失败的结果
     * 相当于一个容器，保存这未来才会结束的事件（异步操作）的一个结果
     * Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理
    */

    /**
     * 特点：(处理异步操作)
     *    1.对象的状态不受外界影响，有三种状态：
     *      1.pending(进行中)
     *      2.fulfilled(已成功)
     *      3.rejected(已失败)
     *    2.状态一旦发生改变，就不会在变,Promise对象的状态改变，只有两种可能：
     *      1.从pending变为fulfilled
     *      2.pending变为rejected
    */
    
    /**
     * Promise是一个构造函数，可以接受一个函数作为参数，接受的函数的两个参数是：
     *    resolve：将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved）,在异步操作成功时调用，并将异步操作的结果，作为参数传递出去
     *    reject：将Promise对象的状态从“未完成”变为“失败”即从 pending 变为 rejected）,在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
     * 
     * .then()：接受当前异步操作成功后返回的结果（一个新的Promis实例），then方法可以接受两个回调函数作为参数，不是必填
     *    第一个回调函数是Promise对象的状态变为resolved时调用
     *    第二个回调函数是Promise对象的状态变为rejected时调用。
     * 
     * .catch()：是 .then(null, err => {})的别名
    */
    let p = new Promise(function(resolve, reject){
      // 执行异步操作
      // 模拟异步操作
      let res = {
        code: 200,
        data: {
          msg: "success"
        },
        error: "faild"
      }
      setTimeout(() => {
        if (res.code === 200) {
          resolve(res)
        } else {
          reject(res.error)
        }
      }, 1000)
    })

    p.then(function(res){
      console.log(res?.data);
    }, function(err){
      console.log(err);
    }).catch((err) => {
      console.log(err);
    })
   
  </script>
</body>
</html>