<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>对象的拓展</title>
</head>

<body>

</body>
<script>
  /**
   * 属性名表达式
  */
  let obj = {}
  obj.foo = true  // 直接用标识符作为属性名
  obj['a' + 'bc'] = 123  // 用表达式作为属性名，这时要将表达式放在方括号之内
  // console.log(obj); // {foo: true, abc: 123}

  let foo = {
    sayName() {
      console.log("123");
    }
  }
//  console.log(foo.sayName.name);  // sayName

/**
 * ES6一共有5种方法可以遍历对象的属性
 *    1.for...in  
 *      for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性
 *    2.Object.keys(obj)
 *      Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。
 *    3.Object.getOwnPropertyNames(obj)
 *      Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。
 *    4.Object.getOwnPropertySymbols(obj)
 *      Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。
 *    5.Reflect.ownKeys(obj)
 *      Reflect.ownKeys返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。
*/

/**
 * super关键字
 * this关键字总是指向函数所在的对象，使用super关键字可以让函数指向当前对象的原型对象
*/
// const proto = {
//   foo: 'hello'
// };

// const obj = {
//   foo: 'world',
//   find() {
//     return super.foo;
//   }
// };

// Object.setPrototypeOf(obj, proto);
// obj.find() // "hello"

/**
 * 解构赋值
*/

let {x, y, ...z} = {x:1, y:2, a:3, b:4}
// console.log(x); // 1
// console.log(y); // 2
// console.log(z); // {a: 3, b: 4}


</script>

</html>